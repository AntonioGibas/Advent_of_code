# Dokumentacija PL/I koda za kalibraciju jednadžbi

## Pregled programa

Ovaj PL/I program rješava problem kalibracije jednadžbi gdje trebamo pronaći operatore (`+` ili `*`) koji se mogu umetnuti između brojeva da bi se postigla ciljna vrijednost. Program čita ulazne podatke iz datoteke, analizira svaku jednadžbu i računa ukupni rezultat kalibracije.

## Struktura programa

### Glavni program: ADV7PLI

```pli
ADV7PLI: PROCEDURE OPTIONS(MAIN);
```

**Objašnjenje sintakse:**
- `PROCEDURE OPTIONS(MAIN)` - definira glavnu proceduru programa
- `ADV7PLI` - naziv procedure
- `OPTIONS(MAIN)` - označava da je ovo glavna procedura koja se izvršava prilikom pokretanja

---

## Deklaracije varijabli

### Datotečne deklaracije

```pli
DCL  INFL        FILE RECORD INPUT;
DCL  EOF         BIT(1) INIT('0'B);
```

**Objašnjenje:**
- `DCL` - ključna riječ za deklaraciju varijable
- `INFL` - naziv datoteke za čitanje
- `FILE RECORD INPUT` - tip datoteke (record-oriented input file)
- `EOF` - flag za označavanje kraja datoteke
- `BIT(1)` - varijabla od 1 bita (boolean)
- `INIT('0'B)` - inicijalizacija na '0' (false), 'B' označava binary literal

### Buffer varijable

```pli
DCL  UNOS(850)   CHAR(80);
DCL  TARGET_NIZ(850) CHAR(80);
```

**Objašnjenje:**
- `UNOS(850)` - niz od 850 elemenata, svaki element je string od 80 znakova
- `CHAR(80)` - tip podatka string fiksne duljine od 80 znakova
- Koristi se za čuvanje učitanih linija iz datoteke

### Varijable za ciljna vrijednost

```pli
DCL  TARGET_NUMBER     FIXED BINARY(63) INIT(0);
DCL  TARGET_NUMBER_CHR CHAR(20) VARYING;
```

**Objašnjenje:**
- `FIXED BINARY(63)` - cjelobrojni tip podatka, 63-bitni predznak + vrijednost
- `CHAR(20) VARYING` - string varijabilne duljine, maksimalno 20 znakova
- `VARYING` omogućava da string može biti kraći od maksimalne duljine

### Nizovi za brojeve

```pli
DCL  NUMBERS(15)     FIXED BINARY(63) INIT((15) -1);
DCL  NUMBERS_CHR(15) CHAR(20) VARYING INIT((15)(''));
```

**Objašnjenje:**
- `NUMBERS(15)` - niz od 15 cjelobrojnih vrijednosti
- `INIT((15) -1)` - inicijalizacija svih 15 elemenata na -1
- `NUMBERS_CHR(15)` - niz stringova za privremeno čuvanje brojeva
- `INIT((15)(''))` - inicijalizacija svih 15 elemenata na prazan string

### Indeksi i brojači

```pli
DCL  DOT_IDX    FIXED BINARY(15) INIT(0);
DCL  EOS_IDX    FIXED BINARY(15) INIT(0);
DCL  I          FIXED BINARY(31);
DCL  J          FIXED BINARY(31);
DCL  N          FIXED BINARY(31);
```

**Objašnjenje:**
- `FIXED BINARY(15)` - 15-bitni cjelobrojni tip
- `FIXED BINARY(31)` - 31-bitni cjelobrojni tip
- Koriste se kao indeksi za petlje i pozicije u stringovima

### Varijabla za ukupni rezultat

```pli
DCL  TOTAL_CALIBRATION FIXED BINARY(63) INIT(0);
```

---

## Rukovanje datotekama

### Postavljanje event handlera

```pli
ON ENDFILE(INFL) EOF = '1'B;
```

**Objašnjenje:**
- `ON ENDFILE` - event handler koji se poziva kada se dosegne kraj datoteke
- Kada se dosegne kraj datoteke INFL, postavlja EOF flag na '1' (true)

### Otvaranje i čitanje datoteke

```pli
OPEN FILE(INFL);

DO I = 1 TO DIM(UNOS) WHILE(EOF = '0'B);
   READ FILE(INFL) INTO(UNOS(I));
END;
CLOSE FILE(INFL);
```

**Objašnjenje:**
- `OPEN FILE(INFL)` - otvara datoteku za čitanje
- `DIM(UNOS)` - vraća dimenziju niza (850)
- `WHILE(EOF = '0'B)` - uvjet petlje: nastavi dok nije dosegnut kraj datoteke
- `READ FILE(INFL) INTO(UNOS(I))` - čita jedan record u element niza
- `CLOSE FILE(INFL)` - zatvara datoteku

---

## Glavni processing loop

### Iteracija kroz učitane linije

```pli
DO I = 1 TO DIM(UNOS) WHILE(LENGTH(TRIM(UNOS(I))) > 0);
```

**Objašnjenje:**
- Prolazi kroz sve elemente niza UNOS
- `LENGTH(TRIM(UNOS(I))) > 0` - uvjet da linija nije prazna
- `TRIM()` - uklanja razmake s početka i kraja stringa
- `LENGTH()` - vraća duljinu stringa

### Reset varijabli za svaki red

```pli
TARGET_NUMBER = 0;
TARGET_NUMBER_CHR = '';
DO J = 1 TO 15;
   NUMBERS(J) = -1;
   NUMBERS_CHR(J) = '';
END;
```

**Objašnjenje:**
- Resetira sve varijable prije obrade novog reda
- Postavlja brojeve na -1 kao marker da nisu postavljeni

### Parsing input linije

```pli
DOT_IDX = INDEX(UNOS(I), ':');
IF DOT_IDX = 0 THEN GOTO NEXT_LINE;

EOS_IDX = LENGTH(TRIM(UNOS(I)));

TARGET_NUMBER_CHR = SUBSTR(UNOS(I), 1, DOT_IDX - 1);
TARGET_NUMBER = BINARY(TRIM(TARGET_NUMBER_CHR));
```

**Objašnjenje:**
- `INDEX(string, substring)` - pronalazi poziciju podstringa u stringu
- `GOTO NEXT_LINE` - skoči na label ako nema ':' u liniji
- `SUBSTR(string, start, length)` - izvlači podstring
- `BINARY()` - konvertira string u binarni broj

### Poziv procedure za parsing brojeva

```pli
TARGET_NIZ(I) = TRIM(SUBSTR(UNOS(I), DOT_IDX + 2));
CALL GET_ALL_NUMS(TARGET_NIZ(I), LENGTH(TARGET_NIZ(I)));
```

**Objašnjenje:**
- Izvlači dio stringa nakon ':'
- `CALL procedure_name(parameters)` - poziva proceduru s parametrima

---

## Logika kombinacija operatora

### Izračun broja kombinacija

```pli
MAX_COMBO = 1;
DO J = 1 TO N - 1;
   MAX_COMBO = MAX_COMBO * 2;
END;
```

**Objašnjenje:**
- Za N brojeva ima N-1 pozicija za operatore
- Svaka pozicija može biti '+' ili '*', dakle 2 opcije
- Ukupno kombinacija: 2^(N-1)
- Ova petlja računa 2^(N-1) ručno

### Generiranje kombinacija pomoću bitova

```pli
DO COMBO = 0 TO MAX_COMBO - 1 WHILE(FOUND_SOLUTION = '0'B);
   RESULT = NUMBERS(1);
   BIT_MASK = 1;
   
   DO J = 2 TO N;
      IF MOD(COMBO / BIT_MASK, 2) = 0 THEN
         RESULT = RESULT + NUMBERS(J);
      ELSE
         RESULT = RESULT * NUMBERS(J);
      BIT_MASK = BIT_MASK * 2;
   END;
```

**Objašnjenje logike:**
- `COMBO` ide od 0 do MAX_COMBO-1, svaki broj predstavlja jednu kombinaciju
- Svaki bit broja COMBO određuje operator na toj poziciji
- `BIT_MASK` se koristi za ekstraktiranje pojedinačnih bitova
- `MOD(COMBO / BIT_MASK, 2)` - provjerava vrijednost tog bita:
  - 0 → koristi '+'
  - 1 → koristi '*'
- `BIT_MASK` se udvostručuje za svaki sljedeći bit

**Primjer:**
- Za brojeve [10, 19], N=2, MAX_COMBO=2
- COMBO=0: bit=0 → 10 + 19 = 29
- COMBO=1: bit=1 → 10 * 19 = 190

### Evaluacija s lijeva na desno

```pli
RESULT = NUMBERS(1);
DO J = 2 TO N;
   IF MOD(COMBO / BIT_MASK, 2) = 0 THEN
      RESULT = RESULT + NUMBERS(J);
   ELSE
      RESULT = RESULT * NUMBERS(J);
   BIT_MASK = BIT_MASK * 2;
END;
```

**Objašnjenje:**
- Počinje s prvim brojem
- Iterativно primjenjuje operatore s lijeva na desno
- Nema prioriteta operatora - sve se računa sekvencijalno

---

## Procedura GET_ALL_NUMS

```pli
GET_ALL_NUMS: PROCEDURE(NIZ, EOS_INDEX);
   DCL NIZ         CHAR(80);
   DCL EOS_INDEX   FIXED BINARY(15);
```

**Objašnjenje:**
- Definira proceduru s dva parametra
- `NIZ` - input string za parsing
- `EOS_INDEX` - duljina stringa

### Parsing algoritam

```pli
DO WHILE(CURRENT_POS <= EOS_INDEX & TOKEN_NUM <= 15);
   /* Skip leading spaces */
   DO WHILE(CURRENT_POS <= EOS_INDEX & 
            SUBSTR(NIZ, CURRENT_POS, 1) = ' ');
      CURRENT_POS = CURRENT_POS + 1;
   END;
   
   IF CURRENT_POS > EOS_INDEX THEN LEAVE;
   
   START_POS = CURRENT_POS;
   
   /* Find next space or end */
   DO WHILE(CURRENT_POS <= EOS_INDEX & 
            SUBSTR(NIZ, CURRENT_POS, 1) ^= ' ');
      CURRENT_POS = CURRENT_POS + 1;
   END;
   
   TOKEN = SUBSTR(NIZ, START_POS, CURRENT_POS - START_POS);
   
   IF LENGTH(TRIM(TOKEN)) > 0 THEN DO;
      NUMBERS_CHR(TOKEN_NUM) = TRIM(TOKEN);
      TOKEN_NUM = TOKEN_NUM + 1;
   END;
END;
```

**Objašnjenje logike:**
1. **Preskače razmake** - traži početak sljedećeg broja
2. **Označava početak tokena** - sprema poziciju
3. **Traži kraj tokena** - ide do sljedećeg razmaka
4. **Izvlači token** - koristi SUBSTR s početnom i završnom pozicijom
5. **Sprema token** - ako nije prazan, dodaje ga u niz

**Sintaksa:**
- `^=` - operator "nije jednako"
- `LEAVE` - izlazi iz petlje (kao break u C-u)
- `&` - logički AND operator

---

## Finalni ispis

```pli
PUT SKIP EDIT('UKUPNI REZULTAT KALIBRACIJE: ', TOTAL_CALIBRATION)(A, F(20));
```

**Objašnjenje:**
- `PUT` - naredba za ispis
- `SKIP` - dodaje novi red prije ispisa
- `EDIT` - formatiran ispis
- `(A, F(20))` - format specifikatori:
  - `A` - ispis stringa kako jest
  - `F(20)` - ispis broja u formatu s 20 mjesta

---

## Ključne značajke programa

### 1. Robust handling velikih brojeva
- Koristi `FIXED BINARY(63)` umjesto `FIXED DECIMAL`
- Može rukuje brojevima do 2^62

### 2. Efikasno generiranje kombinacija
- Koristi bitovne operacije za generiranje svih kombinacija
- Vremenska složenost: O(2^n) gdje je n broj operatora

### 3. Error handling
- Preskače loše formirane linije (bez ':')
- Rukuje praznim linijama

### 4. Memory efficient
- Koristi fiksne nizove umjesto dinamičke alokacije
- Optimizirano za PL/I environment

### 5. Left-to-right evaluacija
- Poštuje zahtjev da se izrazi evaluiraju s lijeva na desno
- Nema operator precedence

Ovaj kod uspješno rješava problem kalibracije jednadžbi pronalaženjem svih mogućih kombinacija operatora i vraćanjem ukupne sume target vrijednosti za jednadžbe koje imaju rješenje.